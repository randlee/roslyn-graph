<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDF Explorer - Assembly Type Graph Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
        }
        .container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
        }
        header {
            grid-column: 1 / -1;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            padding: 0 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        h1 {
            font-size: 1.3em;
            color: #fff;
            font-weight: 500;
        }
        .upload-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }
        .upload-btn:hover {
            background: #1177bb;
        }
        input[type="file"] {
            display: none;
        }
        .sidebar {
            background: #252526;
            border-right: 1px solid #3e3e42;
            overflow-y: auto;
            padding: 15px;
        }
        .sidebar h2 {
            font-size: 0.9em;
            color: #999;
            text-transform: uppercase;
            margin-bottom: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .namespace-header-buttons {
            display: flex;
            gap: 4px;
        }
        .icon-btn {
            background: transparent;
            border: 1px solid #555;
            color: #999;
            cursor: pointer;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 0.85em;
            transition: all 0.2s;
            position: relative;
        }
        .icon-btn:hover {
            background: #3c3c3c;
            border-color: #007acc;
            color: #007acc;
        }
        .icon-btn:active {
            background: #094771;
        }
        .icon-btn[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            right: 0;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 0.75em;
            white-space: nowrap;
            margin-bottom: 4px;
            z-index: 1000;
            border: 1px solid #555;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        .namespace-list, .type-list {
            margin-bottom: 20px;
        }
        .namespace-item, .type-item {
            padding: 4px 8px;
            margin: 1px 0;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85em;
            transition: background 0.2s;
        }
        .namespace-item:hover, .type-item:hover {
            background: #2a2d2e;
        }
        .namespace-item.active, .type-item.active {
            background: #094771;
            color: #fff;
        }
        .type-icon {
            display: inline-block;
            width: 16px;
            margin-right: 8px;
            text-align: center;
        }
        .search-box {
            width: 100%;
            padding: 8px;
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 4px;
            color: #d4d4d4;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        .search-box:focus {
            outline: none;
            border-color: #007acc;
        }
        #cy {
            background: #1e1e1e;
        }
        .details-panel {
            background: #252526;
            border-left: 1px solid #3e3e42;
            overflow-y: auto;
            padding: 20px;
        }
        .details-panel h2 {
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #fff;
            border-bottom: 2px solid #007acc;
            padding-bottom: 8px;
        }
        .detail-section {
            margin-bottom: 20px;
        }
        .detail-section h3 {
            font-size: 0.85em;
            color: #999;
            text-transform: uppercase;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .detail-item {
            padding: 6px 0;
            border-bottom: 1px solid #333;
            font-size: 0.9em;
        }
        .detail-item:last-child {
            border-bottom: none;
        }
        .detail-item[data-tooltip] {
            position: relative;
            cursor: help;
        }
        .member-name {
            color: #dcdcaa;
            font-weight: 500;
        }
        .member-type {
            color: #4ec9b0;
            margin-left: 10px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: #2d2d30;
            padding: 12px;
            border-radius: 4px;
            border-left: 3px solid #007acc;
        }
        .stat-label {
            font-size: 0.75em;
            color: #999;
            margin-bottom: 4px;
        }
        .stat-value {
            font-size: 1.5em;
            color: #4ec9b0;
            font-weight: 600;
        }
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            text-align: center;
            padding: 40px;
        }
        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }
        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.75em;
            margin-left: 8px;
            background: #094771;
        }
        .namespace-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .namespace-checkbox {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid #555;
            border-radius: 3px;
            background: #3c3c3c;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
        }
        .namespace-checkbox:checked {
            background: #007acc;
            border-color: #007acc;
        }
        .namespace-checkbox:checked::after {
            content: '‚úì';
            position: absolute;
            color: white;
            font-size: 12px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .namespace-checkbox:hover {
            border-color: #007acc;
        }
        .namespace-label {
            flex: 1;
            cursor: pointer;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .loading-spinner {
            border: 4px solid #333;
            border-top: 4px solid #007acc;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .method-tooltip {
            position: fixed;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #555;
            font-size: 0.85em;
            font-family: 'Consolas', 'Monaco', monospace;
            z-index: 2000;
            max-width: 400px;
            word-wrap: break-word;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
            pointer-events: none;
            white-space: pre-wrap;
        }
        .menu-button {
            position: relative;
            display: inline-block;
        }
        .menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: #2d2d30;
            border: 1px solid #555;
            border-radius: 4px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
            z-index: 1000;
        }
        .menu-section {
            padding: 8px 0;
        }
        .menu-header {
            padding: 6px 12px;
            font-size: 0.75em;
            color: #999;
            text-transform: uppercase;
            font-weight: 600;
        }
        .menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
            display: flex;
            flex-direction: column;
        }
        .menu-item:hover {
            background: #094771;
        }
        .menu-item.single-line {
            flex-direction: row;
            align-items: center;
            gap: 8px;
        }
        .menu-separator {
            height: 1px;
            background: #555;
            margin: 4px 0;
        }
        .mru-file-name {
            color: #d4d4d4;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .mru-file-meta {
            font-size: 0.8em;
            color: #888;
            margin-top: 2px;
        }
        .menu-empty {
            padding: 12px;
            color: #666;
            font-size: 0.85em;
            text-align: center;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç RDF Explorer - Assembly Type Graph</h1>
            <div class="menu-button">
                <button class="upload-btn" id="load-menu-btn">‚ñº Load RDF File</button>
                <div class="menu-dropdown" id="load-menu" style="display:none">
                    <div class="menu-section" id="mru-section">
                        <div class="menu-header">Recent Files</div>
                        <div id="mru-list"></div>
                    </div>
                    <div class="menu-separator"></div>
                    <div class="menu-item single-line" id="load-new">üìÅ Load new file...</div>
                    <div class="menu-item single-line" id="clear-history">üóëÔ∏è Clear history</div>
                </div>
                <input type="file" id="file-input" accept=".nt,.ttl" style="display: none;">
            </div>
        </header>

        <aside class="sidebar">
            <input type="text" class="search-box" id="search-box" placeholder="Search types...">

            <div class="stats-grid" id="stats-grid" style="display: none;">
                <div class="stat-card">
                    <div class="stat-label">Types</div>
                    <div class="stat-value" id="type-count">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Namespaces</div>
                    <div class="stat-value" id="ns-count">0</div>
                </div>
            </div>

            <div class="namespace-list" id="namespace-list">
                <h2>Namespaces</h2>
                <div class="empty-state">
                    <div class="empty-state-icon">üì¶</div>
                    <p>Load an RDF file to explore types</p>
                </div>
            </div>
        </aside>

        <main id="cy"></main>

        <aside class="details-panel" id="details-panel">
            <div class="empty-state">
                <div class="empty-state-icon">üëà</div>
                <p>Select a type from the graph or sidebar to view details</p>
            </div>
        </aside>
    </div>

    <script>
        let cy;
        let graphData = {
            types: new Map(),
            namespaces: new Map(),
            relationships: [],
            members: new Map(), // Store member details
            parameters: new Map() // Store parameter details
        };
        let visibleNamespaces = new Set(); // Track checked namespaces
        let settings = {
            mruFiles: []
        };

        const fileInput = document.getElementById('file-input');
        const searchBox = document.getElementById('search-box');
        const namespaceList = document.getElementById('namespace-list');
        const detailsPanel = document.getElementById('details-panel');
        const statsGrid = document.getElementById('stats-grid');
        const loadMenuBtn = document.getElementById('load-menu-btn');
        const loadMenu = document.getElementById('load-menu');
        const loadNewBtn = document.getElementById('load-new');
        const clearHistoryBtn = document.getElementById('clear-history');
        const mruList = document.getElementById('mru-list');

        // LocalStorage Settings Management
        function loadSettings() {
            try {
                const stored = localStorage.getItem('rdfExplorerSettings');
                if (stored) {
                    settings = JSON.parse(stored);
                    if (!Array.isArray(settings.mruFiles)) {
                        settings.mruFiles = [];
                    }
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
                settings = { mruFiles: [] };
            }
        }

        function saveSettings() {
            try {
                localStorage.setItem('rdfExplorerSettings', JSON.stringify(settings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }

        function addToMRU(fileName, fileSize) {
            // Remove existing entry with same name
            settings.mruFiles = settings.mruFiles.filter(f => f.path !== fileName);

            // Add to front
            settings.mruFiles.unshift({
                path: fileName,
                timestamp: new Date().toISOString(),
                size: fileSize
            });

            // Keep only 10 most recent
            settings.mruFiles = settings.mruFiles.slice(0, 10);

            saveSettings();
            updateMRUDisplay();
        }

        function clearMRU() {
            settings.mruFiles = [];
            saveSettings();
            updateMRUDisplay();
        }

        function updateMRUDisplay() {
            if (settings.mruFiles.length === 0) {
                mruList.innerHTML = '<div class="menu-empty">No recent files</div>';
                return;
            }

            mruList.innerHTML = settings.mruFiles.map((file, index) => {
                const date = new Date(file.timestamp);
                const timeStr = date.toLocaleString();
                const sizeStr = formatFileSize(file.size);
                const fileName = file.path.split(/[/\\]/).pop(); // Get filename only

                return `
                    <div class="menu-item" data-mru-index="${index}">
                        <div class="mru-file-name" title="${escapeHtml(file.path)}">${escapeHtml(fileName)}</div>
                        <div class="mru-file-meta">${timeStr} ‚Ä¢ ${sizeStr}</div>
                    </div>
                `;
            }).join('');

            // Add click handlers
            document.querySelectorAll('[data-mru-index]').forEach(item => {
                item.addEventListener('click', () => {
                    const index = parseInt(item.dataset.mruIndex);
                    loadFromMRU(index);
                });
            });
        }

        function loadFromMRU(index) {
            const file = settings.mruFiles[index];
            if (!file) return;

            // Close menu
            loadMenu.style.display = 'none';

            // Directly open file picker
            fileInput.click();
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Initialize Cytoscape
        function initGraph() {
            cy = cytoscape({
                container: document.getElementById('cy'),
                style: [
                    {
                        selector: 'node',
                        style: {
                            'background-color': '#4ec9b0',
                            'label': 'data(label)',
                            'color': '#fff',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'font-size': '10px',
                            'width': 60,
                            'height': 60
                        }
                    },
                    {
                        selector: 'node.class',
                        style: {
                            'background-color': '#4ec9b0',
                            'shape': 'rectangle'
                        }
                    },
                    {
                        selector: 'node.interface',
                        style: {
                            'background-color': '#b5cea8',
                            'shape': 'diamond'
                        }
                    },
                    {
                        selector: 'node.struct',
                        style: {
                            'background-color': '#9cdcfe',
                            'shape': 'octagon'
                        }
                    },
                    {
                        selector: 'node.enum',
                        style: {
                            'background-color': '#dcdcaa',
                            'shape': 'triangle'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': '#666',
                            'target-arrow-color': '#666',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'label': 'data(label)',
                            'font-size': '8px',
                            'color': '#999'
                        }
                    },
                    {
                        selector: 'edge.inherits',
                        style: {
                            'line-color': '#569cd6',
                            'target-arrow-color': '#569cd6'
                        }
                    },
                    {
                        selector: 'edge.implements',
                        style: {
                            'line-color': '#b5cea8',
                            'target-arrow-color': '#b5cea8',
                            'line-style': 'dashed'
                        }
                    }
                ],
                layout: {
                    name: 'cose',
                    padding: 50,
                    nodeRepulsion: 8000,
                    idealEdgeLength: 100
                }
            });

            cy.on('tap', 'node', function(evt) {
                const node = evt.target;
                const typeId = node.id();
                showTypeDetails(typeId);
            });
        }

        // Menu toggle
        loadMenuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isVisible = loadMenu.style.display === 'block';
            loadMenu.style.display = isVisible ? 'none' : 'block';
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!loadMenu.contains(e.target) && e.target !== loadMenuBtn) {
                loadMenu.style.display = 'none';
            }
        });

        // Load new file
        loadNewBtn.addEventListener('click', () => {
            loadMenu.style.display = 'none';
            fileInput.click();
        });

        // Clear history
        clearHistoryBtn.addEventListener('click', () => {
            if (confirm('Clear all recent files history?')) {
                clearMRU();
            }
            loadMenu.style.display = 'none';
        });

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            showLoading();
            const text = await file.text();
            await parseRDF(text);
            buildGraph();
            updateUI();
            hideLoading();

            // Add to MRU
            addToMRU(file.name, file.size);

            // Reset file input so same file can be loaded again
            fileInput.value = '';
        });

        searchBox.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            filterTypes(query);
        });

        async function parseRDF(text) {
            graphData = {
                types: new Map(),
                namespaces: new Map(),
                relationships: [],
                members: new Map(),
                parameters: new Map()
            };

            const lines = text.split('\n').filter(l => l.trim() && !l.startsWith('#'));
            const dtOntology = 'http://dotnet.example/ontology/';
            const rdfType = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';

            // Parse triples
            for (const line of lines) {
                const match = line.match(/<([^>]+)>\s+<([^>]+)>\s+(<([^>]+)>|"([^"]*)")/);
                if (!match) continue;

                const subject = match[1];
                const predicate = match[2];
                const objectIri = match[4];
                const objectLiteral = match[5];

                // Extract type information
                if (predicate === rdfType && objectIri) {
                    const typeName = objectIri.replace(dtOntology, '');
                    if (['Class', 'Interface', 'Struct', 'Enum'].includes(typeName)) {
                        if (!graphData.types.has(subject)) {
                            graphData.types.set(subject, {
                                iri: subject,
                                kind: typeName.toLowerCase(),
                                name: '',
                                namespace: '',
                                members: [],
                                inherits: [],
                                implements: []
                            });
                        }
                        graphData.types.get(subject).kind = typeName.toLowerCase();
                    }
                    // Extract member types
                    if (['Method', 'Property', 'Field', 'Event', 'Constructor'].includes(typeName)) {
                        if (!graphData.members.has(subject)) {
                            graphData.members.set(subject, {
                                iri: subject,
                                kind: typeName.toLowerCase(),
                                name: '',
                                returnType: '',
                                parameters: []
                            });
                        }
                        graphData.members.get(subject).kind = typeName.toLowerCase();
                    }
                    // Extract parameter types
                    if (typeName === 'Parameter') {
                        if (!graphData.parameters.has(subject)) {
                            graphData.parameters.set(subject, {
                                iri: subject,
                                name: '',
                                parameterType: '',
                                ordinal: 0
                            });
                        }
                    }
                }

                // Extract name
                if (predicate === dtOntology + 'name' && objectLiteral) {
                    if (graphData.types.has(subject)) {
                        graphData.types.get(subject).name = objectLiteral;
                    }
                    if (graphData.members.has(subject)) {
                        graphData.members.get(subject).name = objectLiteral;
                    }
                    if (graphData.parameters.has(subject)) {
                        graphData.parameters.get(subject).name = objectLiteral;
                    }
                }

                // Extract return type for members
                if (predicate === dtOntology + 'returnType' && objectIri) {
                    if (graphData.members.has(subject)) {
                        graphData.members.get(subject).returnType = objectIri;
                    }
                }

                // Extract parameter type
                if (predicate === dtOntology + 'parameterType' && objectIri) {
                    if (graphData.parameters.has(subject)) {
                        graphData.parameters.get(subject).parameterType = objectIri;
                    }
                }

                // Extract parameter ordinal
                if (predicate === dtOntology + 'ordinal' && objectLiteral) {
                    if (graphData.parameters.has(subject)) {
                        graphData.parameters.get(subject).ordinal = parseInt(objectLiteral);
                    }
                }

                // Extract hasParameter relationship
                if (predicate === dtOntology + 'hasParameter' && objectIri) {
                    if (graphData.members.has(subject)) {
                        graphData.members.get(subject).parameters.push(objectIri);
                    }
                }

                // Extract namespace
                if (predicate === dtOntology + 'inNamespace' && objectIri) {
                    if (graphData.types.has(subject)) {
                        const ns = objectIri;
                        graphData.types.get(subject).namespace = ns;
                        if (!graphData.namespaces.has(ns)) {
                            graphData.namespaces.set(ns, { iri: ns, name: '', types: [] });
                        }
                        graphData.namespaces.get(ns).types.push(subject);
                    }
                }

                // Extract relationships
                if (predicate === dtOntology + 'inherits') {
                    if (graphData.types.has(subject)) {
                        graphData.types.get(subject).inherits.push(objectIri);
                        graphData.relationships.push({
                            from: subject,
                            to: objectIri,
                            type: 'inherits'
                        });
                    }
                }

                if (predicate === dtOntology + 'implements') {
                    if (graphData.types.has(subject)) {
                        graphData.types.get(subject).implements.push(objectIri);
                        graphData.relationships.push({
                            from: subject,
                            to: objectIri,
                            type: 'implements'
                        });
                    }
                }

                // Extract members
                if (predicate === dtOntology + 'hasMember') {
                    if (graphData.types.has(subject)) {
                        graphData.types.get(subject).members.push(objectIri);
                    }
                }
            }

            // Get namespace names
            for (const line of lines) {
                const match = line.match(/<([^>]+)>\s+<([^>]+)>\s+"([^"]*)"/);
                if (!match) continue;
                const subject = match[1];
                const predicate = match[2];
                const literal = match[3];

                if (predicate === dtOntology + 'name' && graphData.namespaces.has(subject)) {
                    graphData.namespaces.get(subject).name = literal;
                }
            }

            // Initialize all namespaces as visible
            visibleNamespaces.clear();
            graphData.namespaces.forEach((ns, iri) => visibleNamespaces.add(iri));
        }

        function buildGraph() {
            const elements = [];

            // Add nodes (only for visible namespaces, excluding compiler-generated types)
            graphData.types.forEach((type, iri) => {
                // Filter out compiler-generated types
                if (isCompilerGenerated(type.name)) return;

                // Show type if it has a name AND (no namespace assigned OR namespace is visible)
                const shouldShow = type.name && (!type.namespace || visibleNamespaces.has(type.namespace));
                if (shouldShow) {
                    elements.push({
                        data: {
                            id: iri,
                            label: type.name,
                            kind: type.kind,
                            namespace: type.namespace
                        },
                        classes: type.kind
                    });
                }
            });

            // Add edges (only between visible nodes)
            const visibleIris = new Set(elements.map(el => el.data.id));
            graphData.relationships.forEach(rel => {
                if (visibleIris.has(rel.from) && visibleIris.has(rel.to)) {
                    elements.push({
                        data: {
                            source: rel.from,
                            target: rel.to,
                            label: rel.type
                        },
                        classes: rel.type
                    });
                }
            });

            cy.elements().remove();
            cy.add(elements);
            cy.layout({
                name: 'cose',
                padding: 50,
                nodeRepulsion: 8000,
                idealEdgeLength: 100,
                animate: true
            }).run();
        }

        function updateUI() {
            // Count non-compiler-generated types
            const nonCompilerTypes = Array.from(graphData.types.values())
                .filter(type => !isCompilerGenerated(type.name));

            // Update stats
            document.getElementById('type-count').textContent = nonCompilerTypes.length;
            document.getElementById('ns-count').textContent = graphData.namespaces.size;
            statsGrid.style.display = 'grid';

            // Update namespace list with checkboxes
            const sorted = Array.from(graphData.namespaces.values())
                .filter(ns => ns.name)
                .sort((a, b) => a.name.localeCompare(b.name));

            namespaceList.innerHTML = `
                <h2>
                    <span>Namespaces</span>
                    <div class="namespace-header-buttons">
                        <button class="icon-btn" id="select-all-btn" data-tooltip="Select all namespaces">‚òë</button>
                        <button class="icon-btn" id="select-none-btn" data-tooltip="Deselect all namespaces">‚òê</button>
                    </div>
                </h2>
            ` + sorted.map(ns => {
                // Count non-compiler-generated types in this namespace
                const typeCount = ns.types.filter(typeIri => {
                    const type = graphData.types.get(typeIri);
                    return type && !isCompilerGenerated(type.name);
                }).length;

                return `<div class="namespace-item" data-ns="${ns.iri}">
                    <input type="checkbox" class="namespace-checkbox" data-ns="${ns.iri}" checked>
                    <span class="namespace-label">üìÅ ${ns.name} <span class="badge">${typeCount}</span></span>
                </div>`;
            }).join('');

            // Add select all/none button listeners
            document.getElementById('select-all-btn')?.addEventListener('click', () => {
                document.querySelectorAll('.namespace-checkbox').forEach(checkbox => {
                    checkbox.checked = true;
                    visibleNamespaces.add(checkbox.dataset.ns);
                });
                buildGraph();
            });

            document.getElementById('select-none-btn')?.addEventListener('click', () => {
                document.querySelectorAll('.namespace-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                    visibleNamespaces.delete(checkbox.dataset.ns);
                });
                buildGraph();
            });

            // Add checkbox event listeners
            document.querySelectorAll('.namespace-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    const nsIri = checkbox.dataset.ns;
                    if (checkbox.checked) {
                        visibleNamespaces.add(nsIri);
                    } else {
                        visibleNamespaces.delete(nsIri);
                    }
                    buildGraph();
                });
            });

            // Add namespace label click listeners
            document.querySelectorAll('.namespace-label').forEach(label => {
                label.addEventListener('click', (e) => {
                    const nsIri = label.parentElement.dataset.ns;
                    focusNamespace(nsIri);
                });
            });
        }

        function focusNamespace(nsIri) {
            const ns = graphData.namespaces.get(nsIri);
            if (!ns) return;

            const typeNodes = ns.types.map(iri => cy.getElementById(iri));
            cy.elements().removeClass('highlighted');
            typeNodes.forEach(node => node.addClass('highlighted'));
            cy.fit(typeNodes, 50);
        }

        function showTypeDetails(typeIri) {
            const type = graphData.types.get(typeIri);
            if (!type) return;

            const kindIcon = {
                'class': 'üèõÔ∏è',
                'interface': 'üîå',
                'struct': 'üì¶',
                'enum': 'üî¢'
            }[type.kind] || 'üìÑ';

            // Categorize members
            const categorized = {
                constructor: [],
                property: [],
                method: [],
                field: [],
                event: []
            };

            type.members.forEach(memberIri => {
                const member = graphData.members.get(memberIri);
                if (member && member.name) {
                    categorized[member.kind]?.push(member);
                }
            });

            let html = `
                <h2>${kindIcon} ${type.name}</h2>
                <div class="detail-section">
                    <h3>Type Information</h3>
                    <div class="detail-item"><strong>Kind:</strong> ${type.kind}</div>
                    <div class="detail-item"><strong>Total Members:</strong> ${type.members.length}</div>
                </div>
            `;

            if (type.inherits.length > 0) {
                html += `<div class="detail-section">
                    <h3>Inherits</h3>
                    ${type.inherits.map(iri => {
                        const base = graphData.types.get(iri);
                        if (base && base.name) {
                            return `<div class="detail-item" data-tooltip="${escapeHtml(base.name)}">${base.name}</div>`;
                        } else {
                            const fullTypeName = getTypeName(iri);
                            const simpleTypeName = getSimpleTypeName(fullTypeName);
                            return `<div class="detail-item" style="color: #888;" data-tooltip="${escapeHtml(fullTypeName)}">${simpleTypeName} <span style="font-size: 0.85em;">(external)</span></div>`;
                        }
                    }).join('')}
                </div>`;
            }

            if (type.implements.length > 0) {
                html += `<div class="detail-section">
                    <h3>Implements</h3>
                    ${type.implements.map(iri => {
                        const iface = graphData.types.get(iri);
                        if (iface && iface.name) {
                            return `<div class="detail-item" data-tooltip="${escapeHtml(iface.name)}">${iface.name}</div>`;
                        } else {
                            const fullTypeName = getTypeName(iri);
                            const simpleTypeName = getSimpleTypeName(fullTypeName);
                            return `<div class="detail-item" style="color: #888;" data-tooltip="${escapeHtml(fullTypeName)}">${simpleTypeName} <span style="font-size: 0.85em;">(external)</span></div>`;
                        }
                    }).join('')}
                </div>`;
            }

            // Add member sections
            if (categorized.constructor.length > 0) {
                html += `<div class="detail-section">
                    <h3>Constructors (${categorized.constructor.length})</h3>
                    ${categorized.constructor.map(member => {
                        const params = getParameterSignature(member.parameters);
                        const fullSignature = `${member.name}(${params})`;
                        return `<div class="detail-item" data-tooltip="${escapeHtml(fullSignature)}">
                            <span class="member-name">${member.name}</span>
                        </div>`;
                    }).join('')}
                </div>`;
            }

            if (categorized.property.length > 0) {
                html += `<div class="detail-section">
                    <h3>Properties (${categorized.property.length})</h3>
                    ${categorized.property.map(member => {
                        const returnType = getTypeName(member.returnType);
                        const fullSignature = returnType ? `${returnType} ${member.name}` : member.name;
                        return `<div class="detail-item" data-tooltip="${escapeHtml(fullSignature)}">
                            <span class="member-name">${member.name}</span>
                            ${returnType ? `<span class="member-type">: ${returnType}</span>` : ''}
                        </div>`;
                    }).join('')}
                </div>`;
            }

            if (categorized.method.length > 0) {
                html += `<div class="detail-section">
                    <h3>Methods (${categorized.method.length})</h3>
                    ${categorized.method.map(member => {
                        const returnType = getTypeName(member.returnType);
                        const params = getParameterSignature(member.parameters);
                        const signature = `${returnType || 'void'} ${member.name}(${params})`;
                        return `<div class="detail-item" data-tooltip="${escapeHtml(signature)}">
                            <span class="member-name">${member.name}</span>
                            ${returnType ? `<span class="member-type">: ${returnType}</span>` : ''}
                        </div>`;
                    }).join('')}
                </div>`;
            }

            if (categorized.field.length > 0) {
                html += `<div class="detail-section">
                    <h3>Fields (${categorized.field.length})</h3>
                    ${categorized.field.map(member => {
                        const returnType = getTypeName(member.returnType);
                        const fullSignature = returnType ? `${returnType} ${member.name}` : member.name;
                        return `<div class="detail-item" data-tooltip="${escapeHtml(fullSignature)}">
                            <span class="member-name">${member.name}</span>
                            ${returnType ? `<span class="member-type">: ${returnType}</span>` : ''}
                        </div>`;
                    }).join('')}
                </div>`;
            }

            if (categorized.event.length > 0) {
                html += `<div class="detail-section">
                    <h3>Events (${categorized.event.length})</h3>
                    ${categorized.event.map(member => {
                        const returnType = getTypeName(member.returnType);
                        const fullSignature = returnType ? `${returnType} ${member.name}` : member.name;
                        return `<div class="detail-item" data-tooltip="${escapeHtml(fullSignature)}">
                            <span class="member-name">${member.name}</span>
                            ${returnType ? `<span class="member-type">: ${returnType}</span>` : ''}
                        </div>`;
                    }).join('')}
                </div>`;
            }

            detailsPanel.innerHTML = html;

            // Add tooltip functionality for all detail items
            setupDetailTooltips();
        }

        function setupDetailTooltips() {
            const detailItems = document.querySelectorAll('.detail-item[data-tooltip]');
            let tooltipElement = null;

            detailItems.forEach(item => {
                item.addEventListener('mouseenter', (e) => {
                    const tooltipText = item.dataset.tooltip;
                    if (!tooltipText) return;

                    // Create tooltip
                    tooltipElement = document.createElement('div');
                    tooltipElement.className = 'method-tooltip';
                    tooltipElement.textContent = tooltipText;
                    document.body.appendChild(tooltipElement);

                    // Position tooltip - center on the item
                    const rect = item.getBoundingClientRect();
                    const tooltipWidth = tooltipElement.offsetWidth;
                    const itemCenter = rect.left + (rect.width / 2);
                    const tooltipLeft = itemCenter - (tooltipWidth / 2);

                    // Ensure tooltip doesn't go off-screen left
                    const finalLeft = Math.max(10, tooltipLeft);
                    tooltipElement.style.left = finalLeft + 'px';
                    tooltipElement.style.top = (rect.top - tooltipElement.offsetHeight - 8) + 'px';
                });

                item.addEventListener('mouseleave', () => {
                    if (tooltipElement) {
                        tooltipElement.remove();
                        tooltipElement = null;
                    }
                });
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getParameterSignature(parameterIris) {
            if (!parameterIris || parameterIris.length === 0) return '';

            // Get parameter details and sort by ordinal
            const params = parameterIris
                .map(iri => graphData.parameters.get(iri))
                .filter(p => p) // Filter out undefined
                .sort((a, b) => a.ordinal - b.ordinal);

            // Format as "type name, type name, ..."
            return params.map(param => {
                const typeName = getTypeName(param.parameterType);
                return `${typeName} ${param.name}`;
            }).join(', ');
        }

        function formatGenericTypeName(typeName) {
            if (!typeName) return '';

            // Convert .NET generic syntax to C# generic syntax
            // Pattern: TypeName`N[TypeArg1,TypeArg2,...] -> TypeName<TypeArg1,TypeArg2,...>

            // Handle nested generics recursively
            let result = typeName;

            // Replace backtick+digit pattern (arity marker) followed by brackets
            // Example: IEquatable`1[Temperature] -> IEquatable<Temperature>
            result = result.replace(/`\d+\[/g, '<');

            // Replace closing bracket with closing angle bracket
            // We need to handle nested generics, so we'll do a simple replacement
            // This works for most cases but may need refinement for deeply nested generics
            let depth = 0;
            let chars = result.split('');
            for (let i = 0; i < chars.length; i++) {
                if (chars[i] === '<') depth++;
                else if (chars[i] === '[' && depth > 0) chars[i] = '<';
                else if (chars[i] === ']' && depth > 0) {
                    chars[i] = '>';
                    depth--;
                }
            }
            result = chars.join('');

            return result;
        }

        function getTypeName(typeIri) {
            if (!typeIri) return '';
            const type = graphData.types.get(typeIri);
            if (type && type.name) return type.name;
            // Extract simple name from IRI for external types
            const parts = typeIri.split('/');
            let name = parts[parts.length - 1] || typeIri;
            // Decode URL-encoded characters
            name = decodeURIComponent(name);
            // Format generic type syntax
            return formatGenericTypeName(name);
        }

        function getSimpleTypeName(fullTypeName) {
            if (!fullTypeName) return '';
            // Extract the simple name (last part after final dot)
            // But preserve the generic parameters
            // Example: System.IEquatable<Temperature> -> IEquatable<Temperature>

            // Find the last dot before any generic bracket
            const genericStart = fullTypeName.indexOf('<');
            let namespacePart, genericPart = '';

            if (genericStart !== -1) {
                namespacePart = fullTypeName.substring(0, genericStart);
                genericPart = fullTypeName.substring(genericStart);
            } else {
                namespacePart = fullTypeName;
            }

            // Get the simple name
            const lastDotIndex = namespacePart.lastIndexOf('.');
            const simpleName = lastDotIndex !== -1 ? namespacePart.substring(lastDotIndex + 1) : namespacePart;

            // Recursively simplify generic parameters
            if (genericPart) {
                // Extract content inside <>
                const innerContent = genericPart.substring(1, genericPart.length - 1);
                // Split by comma but respect nested generics
                const params = splitGenericParams(innerContent);
                const simplifiedParams = params.map(p => getSimpleTypeName(p.trim()));
                return simpleName + '<' + simplifiedParams.join(',') + '>';
            }

            return simpleName;
        }

        function splitGenericParams(str) {
            // Split by comma but respect nested generics
            const params = [];
            let current = '';
            let depth = 0;

            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                if (char === '<') depth++;
                else if (char === '>') depth--;
                else if (char === ',' && depth === 0) {
                    params.push(current);
                    current = '';
                    continue;
                }
                current += char;
            }
            if (current) params.push(current);

            return params;
        }

        function isCompilerGenerated(typeName) {
            if (!typeName) return false;
            // Filter out compiler-generated types
            return typeName === '<Module>' ||
                   typeName === '<PrivateImplementationDetails>' ||
                   typeName.startsWith('<>');
        }

        function filterTypes(query) {
            if (!query) {
                cy.elements().style('opacity', 1);
                return;
            }

            cy.nodes().forEach(node => {
                const label = node.data('label').toLowerCase();
                const opacity = label.includes(query) ? 1 : 0.2;
                node.style('opacity', opacity);
            });
        }

        function showLoading() {
            const loading = document.createElement('div');
            loading.className = 'loading';
            loading.innerHTML = '<div class="loading-spinner"></div>';
            loading.id = 'loading';
            document.body.appendChild(loading);
        }

        function hideLoading() {
            const loading = document.getElementById('loading');
            if (loading) loading.remove();
        }

        // Initialize
        loadSettings();
        updateMRUDisplay();
        initGraph();
    </script>
</body>
</html>
